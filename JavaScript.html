<script>
    // State
    let currentStudentIndex = 1;
    let pagesPerStudent = 1;
    let currentFileId = "";
    let currentFileUrl = "";
    let allGrades = [];
    let masterPdfBytes = null; // Store as Uint8Array
    let solutionImagesBase64 = []; // Store solution images

    // Navigation
    function showTab(tabId) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.nav-btn').forEach(el => el.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');
        document.querySelector(`button[onclick="showTab('${tabId}')"]`).classList.add('active');
        if (tabId === 'dashboard') {
            loadFiles();
        }
    }

    // File Upload
    async function handleUpload() {
        const studentFile = document.getElementById('studentFile').files[0];
        const solutionFile = document.getElementById('solutionFile').files[0];
        const statusDiv = document.getElementById('uploadStatus');
        const ppsInput = document.getElementById('pagesPerStudent');

        if (!studentFile) {
            statusDiv.textContent = "Please select a Student PDF.";
            return;
        }

        statusDiv.textContent = "Reading files...";

        // 1. Read Student PDF into memory
        const rawBuffer = await studentFile.arrayBuffer();
        masterPdfBytes = new Uint8Array(rawBuffer);

        // 1b. Calculate Total Students automatically
        try {
            const loadingTask = pdfjsLib.getDocument({ data: masterPdfBytes.slice() });
            const pdf = await loadingTask.promise;
            const totalPages = pdf.numPages;
            const pps = parseInt(ppsInput.value) || 1;
            const calculatedStudents = Math.floor(totalPages / pps);
            document.getElementById('totalStudents').value = calculatedStudents;
            console.log(`PDF loaded: ${totalPages} pages. Est. Students: ${calculatedStudents}`);
        } catch (e) {
            console.error("Error counting pages:", e);
        }

        // 2. Read Solution PDF (if provided)
        if (solutionFile) {
            statusDiv.textContent = "Processing Solution Key...";
            const solutionBytes = await solutionFile.arrayBuffer();
            const solutionUint8 = new Uint8Array(solutionBytes);
            solutionImagesBase64 = await convertPdfToImages(solutionUint8);
        } else {
            solutionImagesBase64 = [];
        }

        // 3. Upload Student PDF to Drive
        statusDiv.textContent = "Uploading Student PDF to Drive...";
        const reader = new FileReader();
        reader.onload = function (e) {
            const data = {
                data: e.target.result.split(',')[1],
                fileName: studentFile.name,
                mimeType: studentFile.type
            };
            google.script.run
                .withSuccessHandler(function (res) {
                    if (res.success) {
                        statusDiv.textContent = "Upload Complete!";
                        loadFiles(); // Refresh dashboard
                        openGrading(res.url, res.fileId, res.name, true);
                    } else {
                        statusDiv.textContent = "Error: " + res.error;
                    }
                })
                .uploadFile(data);
        };
        reader.readAsDataURL(studentFile);
    }

    // Dashboard: Load Files
    function loadFiles() {
        const list = document.getElementById('fileList');
        list.innerHTML = "Loading...";
        google.script.run
            .withSuccessHandler(function (files) {
                list.innerHTML = "";
                if (files.length === 0) {
                    list.innerHTML = "<p>No files found.</p>";
                    return;
                }
                files.forEach(file => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    const nameEl = document.createElement('strong');
                    nameEl.textContent = file.name;
                    const dateEl = document.createElement('small');
                    dateEl.textContent = file.created;
                    dateEl.style.display = 'block';
                    
                    // Grade Button
                    const gradeBtn = document.createElement('button');
                    gradeBtn.textContent = 'Grade This';
                    gradeBtn.onclick = () => openGrading(file.url, file.id, file.name);
                    
                    // Solution Button
                    const solBtn = document.createElement('button');
                    solBtn.textContent = 'Use as Solution';
                    solBtn.className = 'secondary-btn';
                    solBtn.style.marginTop = '5px';
                    solBtn.style.fontSize = '0.8rem';
                    solBtn.onclick = () => loadSolutionFromDrive(file.id, file.name);
                    
                    item.appendChild(nameEl);
                    item.appendChild(dateEl);
                    item.appendChild(document.createElement('br'));
                    item.appendChild(gradeBtn);
                    item.appendChild(solBtn);
                    list.appendChild(item);
                });
            })
            .getDriveFiles();
    }

    // Load Solution from Drive
    function loadSolutionFromDrive(fileId, fileName) {
        if (!confirm(`Load "${fileName}" as the Solution Key?`)) return;
        google.script.run
            .withSuccessHandler(async function (res) {
                if (res.success) {
                    const binaryString = atob(res.data);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    solutionImagesBase64 = await convertPdfToImages(bytes);
                    const infoBox = document.querySelector('.info-box');
                    alert(`Solution Key Loaded: ${fileName} (${solutionImagesBase64.length} pages)`);
                } else {
                    alert("Error loading solution: " + res.error);
                }
            })
            .getFileContent(fileId);
    }

    // Open Grading Tab
    function openGrading(url, id, name, isNewUpload = false) {
        currentFileId = id;
        const inputVal = document.getElementById('pagesPerStudent').value;
        pagesPerStudent = parseInt(inputVal) || 1;
        
        currentStudentIndex = 1;
        showTab('grading');
        
        if (!isNewUpload) {
            const statusDiv = document.getElementById('gradeStatus');
            statusDiv.textContent = "Loading PDF from Drive...";
            google.script.run
                .withSuccessHandler(function (res) {
                    if (res.success) {
                        const binaryString = atob(res.data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        masterPdfBytes = bytes;
                        statusDiv.textContent = "PDF Loaded.";
                        
                        pdfjsLib.getDocument({ data: masterPdfBytes.slice() }).promise.then(pdf => {
                            const total = Math.floor(pdf.numPages / pagesPerStudent);
                            document.getElementById('totalStudents').value = total;
                            updateStudentView(); // Update preview
                        });
                    } else {
                        alert("Error loading PDF: " + res.error);
                    }
                })
                .getFileContent(id);
        } else {
            // New upload, bytes are ready
            updateStudentView();
        }
    }

    // --- NEW: RENDER PAGES DIRECTLY (FIXES EDGE BLOCKING) ---
    async function updateStudentView() {
        document.getElementById('studentLabel').textContent = `Student ${currentStudentIndex}`;
        const startPage = (currentStudentIndex - 1) * pagesPerStudent + 1;
        const endPage = startPage + pagesPerStudent - 1;
        document.getElementById('pageGuide').textContent = `Pages ${startPage}-${endPage}`;
        document.getElementById('gradeStatus').textContent = "";

        const container = document.getElementById('pdfContainer');
        container.innerHTML = ""; // Clear previous pages

        if (!masterPdfBytes) {
            container.innerHTML = '<p style="color:white; margin-top:20px;">No PDF loaded.</p>';
            return;
        }

        try {
            // Load the Master PDF
            const loadingTask = pdfjsLib.getDocument({ data: masterPdfBytes.slice() });
            const pdf = await loadingTask.promise;
            const totalPages = pdf.numPages;

            // Render ONLY the pages for this student
            for (let i = startPage; i <= endPage; i++) {
                if (i > totalPages) break;

                const page = await pdf.getPage(i);
                
                // Create Canvas
                const canvas = document.createElement('canvas');
                canvas.style.boxShadow = "0 4px 8px rgba(0,0,0,0.3)";
                canvas.style.maxWidth = "100%";
                canvas.style.marginBottom = "20px";
                container.appendChild(canvas);

                const viewport = page.getViewport({ scale: 1.5 });
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                await page.render({ canvasContext: context, viewport: viewport }).promise;
            }
        } catch (e) {
            console.error("Render Error:", e);
            container.innerHTML = '<p style="color:#ef4444; margin-top:20px;">Error rendering PDF.</p>';
        }
    }

    function prevStudent() {
        if (currentStudentIndex > 1) {
            currentStudentIndex--;
            updateStudentView();
        }
    }

    function nextStudent() {
        currentStudentIndex++;
        updateStudentView();
    }

    // Helper: Extract pages for a specific student (For Sending to AI)
    async function extractStudentPdfBase64(studentIndex) {
        if (!masterPdfBytes) throw new Error("Master PDF not loaded.");
        const pdfDoc = await PDFLib.PDFDocument.load(masterPdfBytes.slice());
        const newPdf = await PDFLib.PDFDocument.create();
        const startPage = (studentIndex - 1) * pagesPerStudent;
        const endPage = startPage + pagesPerStudent;
        const pageIndices = [];
        for (let i = startPage; i < endPage; i++) {
            if (i < pdfDoc.getPageCount()) pageIndices.push(i);
        }
        if (pageIndices.length === 0) throw new Error("Page range out of bounds.");
        
        const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);
        copiedPages.forEach(page => newPdf.addPage(page));
        const pdfBytes = await newPdf.save();
        return uint8ToBase64(pdfBytes);
    }

    function uint8ToBase64(u8Arr) {
        let CHUNK_SIZE = 0x8000;
        let index = 0;
        let length = u8Arr.length;
        let result = '';
        while (index < length) {
            result += String.fromCharCode.apply(null, u8Arr.subarray(index, Math.min(index + CHUNK_SIZE, length)));
            index += CHUNK_SIZE;
        }
        return btoa(result);
    }

    // Helper: Convert PDF to Images
    async function convertPdfToImages(pdfBytes) {
        const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
        const pdf = await loadingTask.promise;
        const numPages = pdf.numPages;
        const images = [];
        for (let i = 1; i <= numPages; i++) {
            const page = await pdf.getPage(i);
            const scale = 2.0; 
            const viewport = page.getViewport({ scale: scale });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            await page.render({ canvasContext: context, viewport: viewport }).promise;
            const dataUrl = canvas.toDataURL('image/jpeg', 0.6); 
            images.push(dataUrl.split(',')[1]);
        }
        return images;
    }

    // ==========================================
    // CHUNKING & GRADING LOGIC (With Smart Merging)
    // ==========================================
    async function runAutoGrade(isBatch = false) {
        const btn = isBatch ? null : document.querySelector('.small-grade-btn');
        const statusDiv = document.getElementById('gradeStatus');
        const selectedModel = document.getElementById('modelSelect').value;

        if (solutionImagesBase64.length === 0) {
            if (!confirm("⚠️ No Solution Key loaded. Proceed anyway?")) return null;
        }

        if (!isBatch && btn) {
            btn.innerHTML = 'Analyzing...';
            btn.disabled = true;
        }

        try {
            statusDiv.textContent = `Grading Student ${currentStudentIndex}...`;
            
            const studentPdfBase64 = await extractStudentPdfBase64(currentStudentIndex);
            const binaryString = atob(studentPdfBase64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
            
            const allImages = await convertPdfToImages(bytes);
            
            const CHUNK_SIZE = 3;
            const totalChunks = Math.ceil(allImages.length / CHUNK_SIZE);
            
            let mergedResult = {
                student_name: `Student ${currentStudentIndex}`,
                questions: [],
                overall_comments: []
            };

            for (let i = 0; i < totalChunks; i++) {
                const start = i * CHUNK_SIZE;
                const end = start + CHUNK_SIZE;
                const chunkImages = allImages.slice(start, end);
                
                statusDiv.textContent = `Student ${currentStudentIndex}: Part ${i + 1}/${totalChunks}...`;
                
                const chunkData = await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        .callPoeAPI(chunkImages, solutionImagesBase64, currentStudentIndex, selectedModel);
                });

                if (chunkData && !chunkData.error) {
                    if (chunkData.overall_comment) mergedResult.overall_comments.push(chunkData.overall_comment);
                    if (chunkData.questions) {
                        chunkData.questions.forEach(newQ => {
                            const newId = newQ.id.replace(/\s+/g, '').toUpperCase();
                            const existingIndex = mergedResult.questions.findIndex(q => 
                                q.id.replace(/\s+/g, '').toUpperCase() === newId
                            );

                            if (existingIndex === -1) {
                                mergedResult.questions.push(newQ);
                            } else {
                                const existingQ = mergedResult.questions[existingIndex];
                                const isRealScore = (str) => /\d/.test(str); 
                                const newHasScore = isRealScore(newQ.score);
                                const oldHasScore = isRealScore(existingQ.score);

                                if (newHasScore && !oldHasScore) {
                                    mergedResult.questions[existingIndex] = newQ;
                                } else if (newHasScore && oldHasScore) {
                                    mergedResult.questions[existingIndex].comment += ` | ${newQ.comment}`;
                                }
                            }
                        });
                    }
                }
            }

            mergedResult.questions.sort((a, b) => {
                const numA = parseInt(a.id.replace(/\D/g, '')) || 0;
                const numB = parseInt(b.id.replace(/\D/g, '')) || 0;
                return numA - numB;
            });

            let finalObtained = 0;
            let finalTotal = 0;
            let hasDenom = false;

            mergedResult.questions.forEach(q => {
                if (q.score) {
                    const parts = q.score.toString().split('/');
                    const val = parseFloat(parts[0]);
                    if (!isNaN(val)) finalObtained += val;
                    if (parts.length > 1) {
                        const max = parseFloat(parts[1]);
                        if (!isNaN(max)) { finalTotal += max; hasDenom = true; }
                    }
                }
            });

            const finalScoreStr = (hasDenom && finalTotal > 0) ? `${finalObtained}/${finalTotal}` : `${finalObtained}`;
            const finalCommentStr = mergedResult.overall_comments.join("\n---\n");

            statusDiv.textContent = `Student ${currentStudentIndex} Complete! Score: ${finalScoreStr}`;

            if (!isBatch && btn) {
                btn.innerHTML = "Grade Current Student Only";
                btn.disabled = false;
            }

            google.script.run.saveGrade(mergedResult.student_name, finalScoreStr, finalCommentStr);
            
            const gradeRecord = {
                student_name: mergedResult.student_name,
                total_score: finalScoreStr,
                overall_comment: finalCommentStr,
                questions: mergedResult.questions
            };
            
            const existingIdx = allGrades.findIndex(g => g.student_name === gradeRecord.student_name);
            if (existingIdx >= 0) allGrades[existingIdx] = gradeRecord;
            else allGrades.push(gradeRecord);

        } catch (e) {
            console.error(e);
            if (!isBatch && btn) {
                btn.innerHTML = "Grade Current Student Only";
                btn.disabled = false;
            }
            statusDiv.textContent = "Error: " + e.message;
        }
    }

    async function gradeAll() {
        const total = parseInt(document.getElementById('totalStudents').value) || 1;
        const statusDiv = document.getElementById('gradeStatus');
        
        if (!currentFileId) {
            alert("Please select a file first.");
            return;
        }
        if (!confirm(`Are you sure you want to auto-grade ${total} students?`)) return;
        
        allGrades = [];
        for (let i = 1; i <= total; i++) {
            currentStudentIndex = i;
            updateStudentView(); 
            await new Promise(r => setTimeout(r, 500)); 
            
            statusDiv.textContent = `Batch Processing: Student ${i} of ${total}...`;
            await runAutoGrade(true);
            await new Promise(r => setTimeout(r, 1000));
        }
        statusDiv.textContent = "Batch Grading Complete!";
        alert("Batch Grading Complete!");
    }

    function downloadCsv() {
        if (allGrades.length === 0) { alert("No grades available."); return; }
        
        let qKeys = new Set();
        allGrades.forEach(g => { if (g.questions) g.questions.forEach(q => qKeys.add(q.id)); });
        const qHeaders = Array.from(qKeys).sort((a, b) => {
             const numA = parseInt(a.replace(/\D/g, '')) || 0;
             const numB = parseInt(b.replace(/\D/g, '')) || 0;
             return numA - numB;
        });

        // Add Byte Order Mark (BOM) to force UTF-8 in Excel
        let csv = "\uFEFFStudent,Total Score," + qHeaders.map(h => `${h} Score`).join(",") + "\n";
        
        allGrades.forEach(g => {
            let row = `"${g.student_name}","${g.total_score}"`;
            qHeaders.forEach(qId => {
                const q = g.questions ? g.questions.find(item => item.id === qId) : null;
                const qScore = q ? q.score : "";
                row += `,"${qScore}"`;
            });
            csv += row + "\n";
        });
        
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "grades.csv";
        a.click();
    }

    function downloadPdf() {
        if (allGrades.length === 0) { alert("No grades available."); return; }
        const statusDiv = document.getElementById('gradeStatus');
        statusDiv.textContent = "Generating PDF...";
        google.script.run
            .withSuccessHandler(function (url) {
                statusDiv.textContent = "PDF Ready!";
                window.open(url, '_blank');
            })
            .createPdfReport(allGrades);
    }
</script>
