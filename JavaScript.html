<script>
    // ==========================================
    // GLOBAL STATE
    // ==========================================
    let currentStudentIndex = 1;
    let pagesPerStudent = 1;
    let currentFileId = "";
    let currentFileName = ""; 
    let currentFileUrl = "";
    let allGrades = [];
    let masterPdfBytes = null; 
    let solutionImagesBase64 = []; 

    // ==========================================
    // NAVIGATION
    // ==========================================
    function showTab(tabId) {
        document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.nav-btn').forEach(el => el.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');
        document.querySelector(`button[onclick="showTab('${tabId}')"]`).classList.add('active');
        if (tabId === 'dashboard') {
            loadFiles();
        }
    }

    // ==========================================
    // FILE UPLOAD HANDLING
    // ==========================================
    async function handleUpload() {
        const studentFile = document.getElementById('studentFile').files[0];
        const solutionFile = document.getElementById('solutionFile').files[0];
        const statusDiv = document.getElementById('uploadStatus');
        const ppsInput = document.getElementById('pagesPerStudent');

        if (!studentFile) {
            statusDiv.textContent = "Please select a Student PDF.";
            return;
        }

        statusDiv.textContent = "Reading files...";

        // 1. Read Student PDF into memory
        const rawBuffer = await studentFile.arrayBuffer();
        masterPdfBytes = new Uint8Array(rawBuffer);

        // 1b. Calculate Total Students automatically
        try {
            const loadingTask = pdfjsLib.getDocument({ data: masterPdfBytes.slice() });
            const pdf = await loadingTask.promise;
            const totalPages = pdf.numPages;
            const pps = parseInt(ppsInput.value) || 1;
            const calculatedStudents = Math.floor(totalPages / pps);
            document.getElementById('totalStudents').value = calculatedStudents;
            console.log(`PDF loaded: ${totalPages} pages. Est. Students: ${calculatedStudents}`);
        } catch (e) {
            console.error("Error counting pages:", e);
        }

        // 2. Read Solution PDF (if provided)
        if (solutionFile) {
            statusDiv.textContent = "Processing Solution Key...";
            const solutionBytes = await solutionFile.arrayBuffer();
            const solutionUint8 = new Uint8Array(solutionBytes);
            solutionImagesBase64 = await convertPdfToImages(solutionUint8);
        } else {
            solutionImagesBase64 = [];
        }

        // 3. Upload Student PDF to Drive
        statusDiv.textContent = "Uploading Student PDF to Drive...";
        const reader = new FileReader();
        reader.onload = function (e) {
            const data = {
                data: e.target.result.split(',')[1],
                fileName: studentFile.name,
                mimeType: studentFile.type
            };
            google.script.run
                .withSuccessHandler(function (res) {
                    if (res.success) {
                        statusDiv.textContent = "Upload Complete!";
                        // FIX: Add delay for Drive indexing
                        setTimeout(() => {
                            loadFiles(); // Refresh dashboard
                            openGrading(res.url, res.fileId, res.name, true);
                        }, 2000);
                    } else {
                        statusDiv.textContent = "Error: " + res.error;
                    }
                })
                .withFailureHandler(function(err) {
                    statusDiv.textContent = "Server Error: " + err.message;
                })
                .uploadFile(data);
        };
        reader.readAsDataURL(studentFile);
    }

    // ==========================================
    // DASHBOARD LOGIC (FIXED)
    // ==========================================
    function loadFiles() {
        const list = document.getElementById('fileList');
        list.innerHTML = "<div class='spinner'></div> Loading files...";
        
        google.script.run
            .withSuccessHandler(function (files) {
                list.innerHTML = "";
                if (!files || files.length === 0) {
                    list.innerHTML = "<p>No files found. (Upload a PDF to start)</p>";
                    return;
                }
                files.forEach(file => {
                    // Card Container
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.style.position = 'relative';
                    if(file.isOrphan) {
                        item.style.border = "1px solid #fca5a5";
                        item.style.background = "#fef2f2";
                    }

                    // Main File Info
                    const nameEl = document.createElement('div');
                    nameEl.innerHTML = `<strong>${file.name}</strong>`;
                    nameEl.style.fontSize = '1.1em';
                    
                    const dateEl = document.createElement('div');
                    dateEl.textContent = `Uploaded: ${file.displayDate}`;
                    dateEl.style.color = '#666';
                    dateEl.style.fontSize = '0.85em';
                    dateEl.style.marginBottom = '10px';

                    // Grade Button
                    const gradeBtn = document.createElement('button');
                    if (file.isOrphan) {
                        gradeBtn.textContent = 'âš ï¸ Source Missing';
                        gradeBtn.className = 'secondary-btn';
                        gradeBtn.disabled = true;
                    } else {
                        gradeBtn.textContent = 'ðŸ“ Grade This Paper';
                        gradeBtn.className = 'primary-btn';
                        gradeBtn.onclick = () => openGrading(file.url, file.id, file.name);
                    }
                    gradeBtn.style.width = '100%';
                    gradeBtn.style.padding = '8px';

                    item.appendChild(nameEl);
                    item.appendChild(dateEl);
                    item.appendChild(gradeBtn);

                    // Generated Reports Section (Children Files)
                    if (file.generatedFiles && file.generatedFiles.length > 0) {
                        const divider = document.createElement('hr');
                        divider.style.border = '0';
                        divider.style.borderTop = '1px solid #eee';
                        divider.style.margin = '10px 0';
                        item.appendChild(divider);

                        const reportLabel = document.createElement('div');
                        reportLabel.textContent = "Generated Reports:";
                        reportLabel.style.fontSize = '0.85rem';
                        reportLabel.style.fontWeight = 'bold';
                        reportLabel.style.color = '#4b5563';
                        reportLabel.style.marginBottom = '5px';
                        item.appendChild(reportLabel);

                        const reportList = document.createElement('div');
                        reportList.style.display = 'flex';
                        reportList.style.flexDirection = 'column';
                        reportList.style.gap = '5px';

                        // Sort reports newest first
                        file.generatedFiles.sort((a,b) => b.created - a.created); 

                        file.generatedFiles.forEach(report => {
                            const link = document.createElement('a');
                            link.href = report.url;
                            link.target = "_blank";
                            link.style.display = 'flex';
                            link.style.justifyContent = 'space-between';
                            link.style.alignItems = 'center';
                            link.style.textDecoration = 'none';
                            link.style.padding = '6px';
                            link.style.background = '#f9fafb';
                            link.style.borderRadius = '4px';
                            link.style.border = '1px solid #e5e7eb';
                            link.style.fontSize = '0.8rem';

                            // Icon based on type
                            const icon = report.type.includes('PDF') ? 'ðŸ“„' : 'ðŸ“Š';
                            
                            link.innerHTML = `
                                <span style="color:#374151;">${icon} ${report.type}</span>
                                <span style="color:#9ca3af; font-size:0.75rem;">${report.displayDate}</span>
                            `;
                            
                            // Hover effect
                            link.onmouseover = () => link.style.background = '#f3f4f6';
                            link.onmouseout = () => link.style.background = '#f9fafb';
                            
                            reportList.appendChild(link);
                        });
                        item.appendChild(reportList);
                    }

                    list.appendChild(item);
                });
            })
            .withFailureHandler(function(error) {
                list.innerHTML = `<p style="color:red; font-weight:bold;">Error loading files: ${error.message}</p>`;
            })
            .getDriveFiles();
    }

    // ==========================================
    // GRADING VIEW & PDF RENDERING
    // ==========================================
    function openGrading(url, id, name, isNewUpload = false) {
        currentFileId = id;
        currentFileName = name; // Store name for report generation
        const inputVal = document.getElementById('pagesPerStudent').value;
        pagesPerStudent = parseInt(inputVal) || 1;
        
        currentStudentIndex = 1;
        showTab('grading');
        
        if (!isNewUpload) {
            const statusDiv = document.getElementById('gradeStatus');
            statusDiv.textContent = "Loading PDF from Drive...";
            google.script.run
                .withSuccessHandler(function (res) {
                    if (res.success) {
                        const binaryString = atob(res.data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        masterPdfBytes = bytes;
                        statusDiv.textContent = "PDF Loaded.";
                        
                        pdfjsLib.getDocument({ data: masterPdfBytes.slice() }).promise.then(pdf => {
                            const total = Math.floor(pdf.numPages / pagesPerStudent);
                            document.getElementById('totalStudents').value = total;
                            updateStudentView(); 
                        });
                    } else {
                        alert("Error loading PDF: " + res.error);
                    }
                })
                .getFileContent(id);
        } else {
            // New upload, bytes are ready
            updateStudentView();
        }
    }

    // Render Student Pages directly to Canvas
    async function updateStudentView() {
        document.getElementById('studentLabel').textContent = `Student ${currentStudentIndex}`;
        const startPage = (currentStudentIndex - 1) * pagesPerStudent + 1;
        const endPage = startPage + pagesPerStudent - 1;
        document.getElementById('pageGuide').textContent = `Pages ${startPage}-${endPage}`;
        document.getElementById('gradeStatus').textContent = "";

        const container = document.getElementById('pdfContainer');
        container.innerHTML = ""; // Clear previous pages

        if (!masterPdfBytes) {
            container.innerHTML = '<p style="color:white; margin-top:20px;">No PDF loaded.</p>';
            return;
        }

        try {
            const loadingTask = pdfjsLib.getDocument({ data: masterPdfBytes.slice() });
            const pdf = await loadingTask.promise;
            const totalPages = pdf.numPages;

            // Render ONLY the pages for this student
            for (let i = startPage; i <= endPage; i++) {
                if (i > totalPages) break;

                const page = await pdf.getPage(i);
                
                // Create Canvas
                const canvas = document.createElement('canvas');
                canvas.style.boxShadow = "0 4px 8px rgba(0,0,0,0.3)";
                canvas.style.maxWidth = "100%";
                canvas.style.marginBottom = "20px";
                container.appendChild(canvas);

                const viewport = page.getViewport({ scale: 1.5 });
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                await page.render({ canvasContext: context, viewport: viewport }).promise;
            }
        } catch (e) {
            console.error("Render Error:", e);
            container.innerHTML = '<p style="color:#ef4444; margin-top:20px;">Error rendering PDF.</p>';
        }
    }

    function prevStudent() {
        if (currentStudentIndex > 1) {
            currentStudentIndex--;
            updateStudentView();
        }
    }

    function nextStudent() {
        currentStudentIndex++;
        updateStudentView();
    }

    // ==========================================
    // PDF UTILITIES (Extract & Convert)
    // ==========================================
    async function extractStudentPdfBase64(studentIndex) {
        if (!masterPdfBytes) throw new Error("Master PDF not loaded.");
        const pdfDoc = await PDFLib.PDFDocument.load(masterPdfBytes.slice());
        const newPdf = await PDFLib.PDFDocument.create();
        const startPage = (studentIndex - 1) * pagesPerStudent;
        const endPage = startPage + pagesPerStudent;
        const pageIndices = [];
        for (let i = startPage; i < endPage; i++) {
            if (i < pdfDoc.getPageCount()) pageIndices.push(i);
        }
        if (pageIndices.length === 0) throw new Error("Page range out of bounds.");
        
        const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);
        copiedPages.forEach(page => newPdf.addPage(page));
        const pdfBytes = await newPdf.save();
        return uint8ToBase64(pdfBytes);
    }

    function uint8ToBase64(u8Arr) {
        let CHUNK_SIZE = 0x8000;
        let index = 0;
        let length = u8Arr.length;
        let result = '';
        while (index < length) {
            result += String.fromCharCode.apply(null, u8Arr.subarray(index, Math.min(index + CHUNK_SIZE, length)));
            index += CHUNK_SIZE;
        }
        return btoa(result);
    }

    async function convertPdfToImages(pdfBytes) {
        const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
        const pdf = await loadingTask.promise;
        const numPages = pdf.numPages;
        const images = [];
        for (let i = 1; i <= numPages; i++) {
            const page = await pdf.getPage(i);
            const scale = 2.0; 
            const viewport = page.getViewport({ scale: scale });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            await page.render({ canvasContext: context, viewport: viewport }).promise;
            const dataUrl = canvas.toDataURL('image/jpeg', 0.6); 
            images.push(dataUrl.split(',')[1]);
        }
        return images;
    }

    // ==========================================
    // INTELLIGENT GRADING LOGIC (FIXED)
    // ==========================================
    
    // Helper: Detect "Blank" strictly based on score AND keywords
    function isBlankAnswer(q) {
        if (!q.score) return true;
        const scoreVal = parseFloat(q.score.split('/')[0]) || 0;
        const comment = (q.comment || "").toLowerCase();
        
        // It's a blank if Score is 0 AND comment explicitly says it's blank/missing
        if (scoreVal === 0 && (comment.includes("blank") || comment.includes("missing") || comment.includes("æœªä½œç­”"))) {
            return true;
        }
        return false;
    }

    // Helper: Extract numeric score
    function getScoreValue(scoreStr) {
        if (!scoreStr) return 0;
        return parseFloat(scoreStr.split('/')[0]) || 0;
    }

    async function runAutoGrade(isBatch = false) {
        const btn = isBatch ? null : document.querySelector('.small-grade-btn');
        const statusDiv = document.getElementById('gradeStatus');
        const selectedModel = document.getElementById('modelSelect').value;

        if (solutionImagesBase64.length === 0) {
            if (!confirm("âš ï¸ No Solution Key loaded. Proceed anyway?")) return null;
        }

        if (!isBatch && btn) {
            btn.innerHTML = 'Analyzing...';
            btn.disabled = true;
        }

        try {
            statusDiv.textContent = `Grading Student ${currentStudentIndex}...`;
            
            // Prepare Student Content
            const studentPdfBase64 = await extractStudentPdfBase64(currentStudentIndex);
            const binaryString = atob(studentPdfBase64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
            const allImages = await convertPdfToImages(bytes);
            
            // Chunking - 5 PAGES PER REQUEST
            const CHUNK_SIZE = 5;
            const totalChunks = Math.ceil(allImages.length / CHUNK_SIZE);
            
            let mergedResult = {
                student_name: `Student ${currentStudentIndex}`,
                questions: [],
                overall_comments: []
            };

            for (let i = 0; i < totalChunks; i++) {
                const start = i * CHUNK_SIZE;
                const end = start + CHUNK_SIZE;
                const chunkImages = allImages.slice(start, end);
                
                statusDiv.textContent = `Student ${currentStudentIndex}: Part ${i + 1}/${totalChunks}...`;
                
                const chunkData = await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        .callPoeAPI(chunkImages, solutionImagesBase64, currentStudentIndex, selectedModel);
                });

                if (chunkData && !chunkData.error) {
                    if (chunkData.overall_comment) mergedResult.overall_comments.push(chunkData.overall_comment);
                    
                    if (chunkData.questions) {
                        chunkData.questions.forEach(newQ => {
                            // Normalize ID (remove spaces, uppercase)
                            const newId = newQ.id.replace(/\s+/g, '').toUpperCase();
                            const existingIndex = mergedResult.questions.findIndex(q => 
                                q.id.replace(/\s+/g, '').toUpperCase() === newId
                            );

                            if (existingIndex === -1) {
                                // New Question found
                                mergedResult.questions.push(newQ);
                            } else {
                                // Conflict Resolution: Smart Merge
                                const existingQ = mergedResult.questions[existingIndex];
                                
                                const newIsBlank = isBlankAnswer(newQ);
                                const oldIsBlank = isBlankAnswer(existingQ);
                                const newScore = getScoreValue(newQ.score);
                                const oldScore = getScoreValue(existingQ.score);

                                if (!newIsBlank && oldIsBlank) {
                                    // Found actual work in this chunk -> Overwrite the "Blank" from previous chunk
                                    mergedResult.questions[existingIndex] = newQ;
                                } else if (newIsBlank && !oldIsBlank) {
                                    // Already found work -> Ignore this "Blank"
                                    console.log(`Ignoring blank result for ${newId} from chunk ${i+1}`);
                                } else {
                                    // Both Real or Both Blank -> Keep Higher Score (benefit of doubt)
                                    if (newScore > oldScore) {
                                        mergedResult.questions[existingIndex] = newQ;
                                    } 
                                    // Combine comments if not blank
                                    else if (!newIsBlank && !oldIsBlank && newQ.comment !== existingQ.comment) {
                                         mergedResult.questions[existingIndex].comment += ` | ${newQ.comment}`;
                                    }
                                }
                            }
                        });
                    }
                }
            }

            // Sort questions numerically (Handles Non-Chronological Grading)
            mergedResult.questions.sort((a, b) => {
                const numA = parseInt(a.id.replace(/\D/g, '')) || 0;
                const numB = parseInt(b.id.replace(/\D/g, '')) || 0;
                return numA - numB;
            });

            // Calculate Totals locally (Prevents hallucinated totals)
            let finalObtained = 0;
            let finalTotal = 0;
            let hasDenom = false;

            mergedResult.questions.forEach(q => {
                if (q.score) {
                    const parts = q.score.toString().split('/');
                    const val = parseFloat(parts[0]);
                    if (!isNaN(val)) finalObtained += val;
                    if (parts.length > 1) {
                        const max = parseFloat(parts[1]);
                        if (!isNaN(max)) { finalTotal += max; hasDenom = true; }
                    }
                }
            });

            const finalScoreStr = (hasDenom && finalTotal > 0) ? `${finalObtained}/${finalTotal}` : `${finalObtained}`;
            const finalCommentStr = mergedResult.overall_comments.join("\n---\n");

            statusDiv.textContent = `Student ${currentStudentIndex} Complete! Score: ${finalScoreStr}`;

            if (!isBatch && btn) {
                btn.innerHTML = "Grade Current Student Only";
                btn.disabled = false;
            }

            // Save Grade to Sheet
            google.script.run.saveGrade(mergedResult.student_name, finalScoreStr, finalCommentStr);
            
            // Store for Export
            const gradeRecord = {
                student_name: mergedResult.student_name,
                total_score: finalScoreStr,
                overall_comment: finalCommentStr,
                questions: mergedResult.questions
            };
            
            const existingIdx = allGrades.findIndex(g => g.student_name === gradeRecord.student_name);
            if (existingIdx >= 0) allGrades[existingIdx] = gradeRecord;
            else allGrades.push(gradeRecord);

        } catch (e) {
            console.error(e);
            if (!isBatch && btn) {
                btn.innerHTML = "Grade Current Student Only";
                btn.disabled = false;
            }
            statusDiv.textContent = "Error: " + e.message;
        }
    }

    // Batch Grading Loop
    async function gradeAll() {
        const total = parseInt(document.getElementById('totalStudents').value) || 1;
        const statusDiv = document.getElementById('gradeStatus');
        
        if (!currentFileId) {
            alert("Please select a file first.");
            return;
        }
        if (!confirm(`Are you sure you want to auto-grade ${total} students?`)) return;
        
        allGrades = [];
        for (let i = 1; i <= total; i++) {
            currentStudentIndex = i;
            updateStudentView(); 
            await new Promise(r => setTimeout(r, 500)); 
            
            statusDiv.textContent = `Batch Processing: Student ${i} of ${total}...`;
            await runAutoGrade(true);
            await new Promise(r => setTimeout(r, 1000));
        }
        statusDiv.textContent = "Batch Grading Complete!";
        alert("Batch Grading Complete!");
    }

    // ==========================================
    // EXPORT FUNCTIONS
    // ==========================================
    function downloadCsv() {
        if (allGrades.length === 0) { alert("No grades available."); return; }
        
        // Collect all unique Question IDs
        let qKeys = new Set();
        allGrades.forEach(g => { if (g.questions) g.questions.forEach(q => qKeys.add(q.id)); });
        const qHeaders = Array.from(qKeys).sort((a, b) => {
             const numA = parseInt(a.replace(/\D/g, '')) || 0;
             const numB = parseInt(b.replace(/\D/g, '')) || 0;
             return numA - numB;
        });

        // Create CSV Content
        let csv = "\uFEFFStudent,Total Score," + qHeaders.map(h => `${h} Score`).join(",") + "\n";
        
        allGrades.forEach(g => {
            let row = `"${g.student_name}","${g.total_score}"`;
            qHeaders.forEach(qId => {
                const q = g.questions ? g.questions.find(item => item.id === qId) : null;
                const qScore = q ? q.score : "";
                row += `,"${qScore}"`;
            });
            csv += row + "\n";
        });
        
        // Save to Dashboard
        const statusDiv = document.getElementById('gradeStatus');
        statusDiv.textContent = "Saving CSV to Dashboard...";
        
        google.script.run
            .withSuccessHandler(function(res) {
                if(res.success) {
                    statusDiv.textContent = "CSV Saved!";
                    window.open(res.url, '_blank');
                } else {
                    statusDiv.textContent = "Error saving CSV.";
                    alert("Error: " + res.error);
                }
            })
            .saveCsvReport(csv, currentFileName);
    }

    function downloadPdf() {
        if (allGrades.length === 0) { alert("No grades available."); return; }
        const statusDiv = document.getElementById('gradeStatus');
        statusDiv.textContent = "Generating PDF...";
        google.script.run
            .withSuccessHandler(function (url) {
                statusDiv.textContent = "PDF Ready!";
                window.open(url, '_blank');
            })
            .createPdfReport(allGrades, currentFileName);
    }
</script>
