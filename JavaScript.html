// ==========================================
    // CHUNKING & GRADING LOGIC (With Smart Merging)
    // ==========================================
    async function runAutoGrade(isBatch = false) {
        const btn = document.querySelector('.magic-btn');
        const statusDiv = document.getElementById('gradeStatus');
        const commentBox = document.getElementById('commentInput');
        const scoreBox = document.getElementById('scoreInput');
        const selectedModel = document.getElementById('modelSelect').value;

        if (solutionImagesBase64.length === 0) {
            if (!confirm("⚠️ No Solution Key loaded. Proceed anyway?")) return null;
        }

        if (!isBatch) {
            btn.innerHTML = '<span class="spinner"></span> Grading...';
            btn.disabled = true;
        }

        try {
            statusDiv.textContent = `Preparing Student ${currentStudentIndex}...`;
            
            // 1. Get Student PDF & Convert to Images
            const studentPdfBase64 = await extractStudentPdfBase64(currentStudentIndex);
            const binaryString = atob(studentPdfBase64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
            
            const allImages = await convertPdfToImages(bytes);
            
            // 2. Setup Chunking
            const CHUNK_SIZE = 3;
            const totalChunks = Math.ceil(allImages.length / CHUNK_SIZE);
            
            let mergedResult = {
                student_name: `Student ${currentStudentIndex}`,
                questions: [],          // We will manage this list carefully
                overall_comments: []
            };

            // 3. Process Chunks Sequentially
            for (let i = 0; i < totalChunks; i++) {
                const start = i * CHUNK_SIZE;
                const end = start + CHUNK_SIZE;
                const chunkImages = allImages.slice(start, end);
                
                statusDiv.textContent = `Analyzing Part ${i + 1} of ${totalChunks} (Model: ${selectedModel})...`;
                
                const chunkData = await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        .callPoeAPI(chunkImages, solutionImagesBase64, currentStudentIndex, selectedModel);
                });

                if (chunkData && !chunkData.error) {
                    
                    // --- SMART GLUING LOGIC START ---
                    
                    // 1. Merge Comments (Simple Append)
                    if (chunkData.overall_comment) {
                        mergedResult.overall_comments.push(chunkData.overall_comment);
                    }

                    // 2. Merge Questions (Deduplication Strategy)
                    if (chunkData.questions) {
                        chunkData.questions.forEach(newQ => {
                            // Normalize ID (remove spaces, e.g., "Q 1" -> "Q1")
                            const newId = newQ.id.replace(/\s+/g, '').toUpperCase();
                            
                            // Check if we already have this question
                            const existingIndex = mergedResult.questions.findIndex(q => 
                                q.id.replace(/\s+/g, '').toUpperCase() === newId
                            );

                            if (existingIndex === -1) {
                                // Case A: New Question. Add it.
                                mergedResult.questions.push(newQ);
                            } else {
                                // Case B: Duplicate ID found. Pick the "Better" one.
                                const existingQ = mergedResult.questions[existingIndex];
                                
                                // Helper to check if a score is "Real" (contains numbers)
                                const isRealScore = (str) => /\d/.test(str); 
                                
                                const newHasScore = isRealScore(newQ.score);
                                const oldHasScore = isRealScore(existingQ.score);

                                if (newHasScore && !oldHasScore) {
                                    // Upgrade: The new chunk found the real answer, overwrite the old "Empty" placeholder.
                                    mergedResult.questions[existingIndex] = newQ;
                                } 
                                else if (newHasScore && oldHasScore) {
                                    // Conflict: Both chunks graded it. 
                                    // Strategy: Append the comments so the teacher sees both opinions.
                                    mergedResult.questions[existingIndex].comment += ` | ${newQ.comment}`;
                                    // Optional: You could sum the scores, but usually, overwriting is safer for page overlaps.
                                }
                            }
                        });
                    }
                    // --- SMART GLUING LOGIC END ---
                    
                } else {
                    console.error("Chunk Error:", chunkData);
                }
            }

            // 4. Sort Questions Naturally (Q1, Q2, Q3...)
            // This fixes the order if Chunk 2 replies before Chunk 1 (unlikely in this loop, but good safety)
            mergedResult.questions.sort((a, b) => {
                const numA = parseInt(a.id.replace(/\D/g, '')) || 0;
                const numB = parseInt(b.id.replace(/\D/g, '')) || 0;
                return numA - numB;
            });

            // 5. Calculate Final Score (Summation)
            let finalObtained = 0;
            let finalTotal = 0;
            let hasDenom = false;

            mergedResult.questions.forEach(q => {
                if (q.score) {
                    const parts = q.score.toString().split('/');
                    const val = parseFloat(parts[0]);
                    if (!isNaN(val)) finalObtained += val;
                    if (parts.length > 1) {
                        const max = parseFloat(parts[1]);
                        if (!isNaN(max)) { finalTotal += max; hasDenom = true; }
                    }
                }
            });

            const finalScoreStr = (hasDenom && finalTotal > 0) ? `${finalObtained}/${finalTotal}` : `${finalObtained}`;
            const finalCommentStr = mergedResult.overall_comments.join("\n---\n");

            // 6. Update UI
            scoreBox.value = finalScoreStr;
            commentBox.value = finalCommentStr;
            statusDiv.textContent = "Grading Complete!";

            if (!isBatch) {
                btn.innerHTML = "✨ Grade Current Student";
                btn.disabled = false;
            }

            // 7. Save to Sheet
            google.script.run.saveGrade(mergedResult.student_name, finalScoreStr, finalCommentStr);
            
            const gradeRecord = {
                student_name: mergedResult.student_name,
                total_score: finalScoreStr,
                overall_comment: finalCommentStr,
                questions: mergedResult.questions
            };
            
            const existingIdx = allGrades.findIndex(g => g.student_name === gradeRecord.student_name);
            if (existingIdx >= 0) allGrades[existingIdx] = gradeRecord;
            else allGrades.push(gradeRecord);

        } catch (e) {
            console.error(e);
            if (!isBatch) {
                btn.innerHTML = "✨ Grade Current Student";
                btn.disabled = false;
            }
            statusDiv.textContent = "Error: " + e.message;
            alert("Error: " + e.message);
        }
    }
